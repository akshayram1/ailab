/* A* 8puzz Informed strategies O(b^d). f(n)=g(n)+h(n) */

package akshay;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class AStar8puzz {
    static ArrayList<State> output = new ArrayList<>();

    static class StateComparator implements Comparator<State> {
        public int compare(State a, State b) {
            return Integer.compare(a.f, b.f);
        }
    }

    static class State {
        public int[][] board = new int[3][3];
        public int g, f, h;
        public State came_from;

        public State() {
            g = 0;
            f = 0;
            h = 0;
            came_from = null;
        }

        public static int heuristic(State from, State to) {
            int ret = 0;
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (from.board[i][j] != to.board[i][j])
                        ret++;
            return ret;
        }

        public boolean equals(State a) {
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (this.board[i][j] != a.board[i][j])
                        return false;
            return true;
        }

        public void print() {
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++)
                    System.out.print(board[i][j] + " ");
                System.out.println();
            }
            System.out.println("g = " + g + " | h = " + h + " | f = " + f);
        }
    }

    static boolean isinset(State a, ArrayList<State> b) {
        for (int i = 0; i < b.size(); i++)
            if (a.equals(b.get(i)))
                return true;
        return false;
    }

    static void addNeighbor(State current, State goal, int newi, int newj, int posi, int posj,
            ArrayList<State> openset, ArrayList<State> closedset) {
        State newstate = new State();
        for (int i = 0; i < 3; i++)
            newstate.board[i] = current.board[i].clone();

        // Swap operation replacement
        int temp = newstate.board[newi][newj];
        newstate.board[newi][newj] = newstate.board[posi][posj];
        newstate.board[posi][posj] = temp;

        if (!isinset(newstate, closedset) && !isinset(newstate, openset)) {
            newstate.g = current.g + 1;
            newstate.h = State.heuristic(newstate, goal);
            newstate.f = newstate.g + newstate.h;
            newstate.came_from = current;
            openset.add(newstate);
        }
    }

    static void neighbors(State current, State goal, ArrayList<State> openset, ArrayList<State> closedset) {
        int i = 0, j = 0, posi = 0, posj = 0;
        for (i = 0; i < 3; i++)
            for (j = 0; j < 3; j++)
                if (current.board[i][j] == 0) {
                    posi = i;
                    posj = j;
                    break;
                }

        i = posi;
        j = posj;
        if (i - 1 >= 0)
            addNeighbor(current, goal, i - 1, j, posi, posj, openset, closedset);
        if (i + 1 < 3)
            addNeighbor(current, goal, i + 1, j, posi, posj, openset, closedset);
        if (j + 1 < 3)
            addNeighbor(current, goal, i, j + 1, posi, posj, openset, closedset);
        if (j - 1 >= 0)
            addNeighbor(current, goal, i, j - 1, posi, posj, openset, closedset);
    }

    static boolean reconstruct_path(State current, ArrayList<State> came_from) {
        State temp = current;
        while (temp != null) {
            came_from.add(temp);
            temp = temp.came_from;
        }
        return true;
    }

    static boolean astar(State start, State goal) {
        ArrayList<State> openset = new ArrayList<>();
        ArrayList<State> closedset = new ArrayList<>();
        State current = new State();
        start.g = 0;
        start.h = State.heuristic(start, goal);
        start.f = start.g + start.h;
        openset.add(start);
        while (!openset.isEmpty()) {
            openset.sort(new StateComparator());
            current = openset.get(0);
            if (current.equals(goal))
                return reconstruct_path(current, output);
            openset.remove(0);
            closedset.add(current);
            neighbors(current, goal, openset, closedset);
        }
        return false;
    }

    public static void main(String[] args) {
        State start = new State();
        State goal = new State();

        // Initial state
        start.board[0][0] = 2;
        start.board[0][1] = 8;
        start.board[0][2] = 3;
        start.board[1][0] = 1;
        start.board[1][1] = 6;
        start.board[1][2] = 4;
        start.board[2][0] = 7;
        start.board[2][1] = 0;
        start.board[2][2] = 5;

        // Goal state
        goal.board[0][0] = 1;
        goal.board[0][1] = 2;
        goal.board[0][2] = 3;
        goal.board[1][0] = 8;
        goal.board[1][1] = 0;
        goal.board[1][2] = 4;
        goal.board[2][0] = 7;
        goal.board[2][1] = 6;
        goal.board[2][2] = 5;

        if (astar(start, goal)) {
            for (int i = output.size() - 1; i >= 0; i--)
                output.get(i).print();
            System.out.println("SUCCESS!! GOAL STATE REACHED.");
        } else {
            System.out.println("FAIL");
        }
    }
}


//AStarAlgoshortestpath

package akshay;

import java.util.*;

class Node implements Comparable<Node> {
    int id;
    int cost;
    int heuristic;
    Node parent;

    public Node(int id, int cost, int heuristic, Node parent) {
        this.id = id;
        this.cost = cost;
        this.heuristic = heuristic;
        this.parent = parent;
    }

    @Override
    public int compareTo(Node other) {
        return Integer.compare(cost + heuristic, other.cost + other.heuristic);
    }
}

public class AStarAlgoshortestpath {
    public static List<Integer> findShortestPath(int[][] graph, int start, int goal, int[] heuristic) {
        int numNodes = graph.length;
        boolean[] visited = new boolean[numNodes];
        int[] costs = new int[numNodes];
        Arrays.fill(costs, Integer.MAX_VALUE);
        costs[start] = 0;

        PriorityQueue<Node> queue = new PriorityQueue<>();
        queue.add(new Node(start, 0, heuristic[start], null));

        while (!queue.isEmpty()) {
            Node current = queue.poll();
            int currentNode = current.id;

            if (currentNode == goal) {
                List<Integer> path = new ArrayList<>();
                while (current != null) {
                    path.add(current.id);
                    current = current.parent;
                }
                Collections.reverse(path);
                return path;
            }

            if (visited[currentNode]) {
                continue;
            }

            visited[currentNode] = true;

            for (int neighbor = 0; neighbor < numNodes; neighbor++) {
                if (graph[currentNode][neighbor] != 0 && !visited[neighbor]) {
                    int newCost = costs[currentNode] + graph[currentNode][neighbor];
                    if (newCost < costs[neighbor]) {
                        costs[neighbor] = newCost;
                        Node neighborNode = new Node(neighbor, newCost, heuristic[neighbor], current);
                        queue.add(neighborNode);
                    }
                }
            }
        }

        return null;
    }

    public static void main(String[] args) {
        int[][] graph = {
                { 0, 2, 0, 1, 0 },
                { 2, 0, 3, 0, 0 },
                { 0, 3, 0, 0, 4 },
                { 1, 0, 0, 0, 2 },
                { 0, 0, 4, 2, 0 }
        };
        int start = 0;
        int goal = 4;
        int[] heuristic = { 6, 3, 2, 4, 0 };

        List<Integer> path = findShortestPath(graph, start, goal, heuristic);

        if (path != null) {
            System.out.println("Shortest path: " + path);
        } else {
            System.out.println("No path found");
        }
    }
}



//BestFirstSearchshortestpath input 1 5 using hashmap and graph

package akshay;

import java.util.*;

class Node implements Comparable<Node> {
    int value;
    int heuristic;

    public Node(int value, int heuristic) {
        this.value = value;
        this.heuristic = heuristic;
    }

    @Override
    public int compareTo(Node other) {
        return Integer.compare(this.heuristic, other.heuristic);
    }
}

public class BestFirstSearchshortestpath 
 {
    public static void main(String[] args) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(1, 2, 3));
        graph.put(1, Arrays.asList(0, 4));
        graph.put(2, Arrays.asList(0, 4, 5));
        graph.put(3, Arrays.asList(0, 5));
        graph.put(4, Arrays.asList(1, 2, 6));
        graph.put(5, Arrays.asList(2, 3, 6));
        graph.put(6, Arrays.asList(4, 5, 7));
        graph.put(7, Arrays.asList());

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the start state: ");
        int startState = scanner.nextInt();

        System.out.print("Enter the goal state: ");
        int goalState = scanner.nextInt();

        scanner.close();

        Map<Integer, Integer> heuristicValues = calculateManhattanHeuristics(graph, goalState);

        for (Map.Entry<Integer, Integer> entry : heuristicValues.entrySet()) {
            System.out.println("Heuristic for Node " + entry.getKey() + ": " + entry.getValue());
        }

        List<Integer> path = bestFirstSearch(graph, heuristicValues, startState, goalState);
        System.out.println("Path: " + path);
    }

    public static Map<Integer, Integer> calculateManhattanHeuristics(Map<Integer, List<Integer>> graph, int goal) {
        Map<Integer, Integer> heuristicValues = new HashMap<>();

        Map<Integer, int[]> nodeCoordinates = new HashMap<>();
        nodeCoordinates.put(0, new int[] { 0, 0 });
        nodeCoordinates.put(1, new int[] { 5, 8 });
        nodeCoordinates.put(2, new int[] { 8, 5 });
        nodeCoordinates.put(3, new int[] { 12, 2 });
        nodeCoordinates.put(4, new int[] { 3, 3 });
        nodeCoordinates.put(5, new int[] { 7, 7 });
        nodeCoordinates.put(6, new int[] { 11, 11 });
        nodeCoordinates.put(7, new int[] { 15, 15 });

        int[] goalCoordinates = nodeCoordinates.get(goal);

        for (int node : graph.keySet()) {
            int[] coordinates = nodeCoordinates.get(node);
            int distance = calculateManhattanDistance(coordinates, goalCoordinates);
            heuristicValues.put(node, distance);
        }

        return heuristicValues;
    }

    private static int calculateManhattanDistance(int[] point1, int[] point2) {
        return Math.abs(point1[0] - point2[0]) + Math.abs(point1[1] - point2[1]);
    }

    public static List<Integer> bestFirstSearch(Map<Integer, List<Integer>> graph,
            Map<Integer, Integer> heuristicValues, int start, int goal) {
        PriorityQueue<Node> queue = new PriorityQueue<>();
        Map<Integer, Integer> parent = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        queue.offer(new Node(start, heuristicValues.get(start)));

        while (!queue.isEmpty()) {
            Node currentNode = queue.poll();
            int current = currentNode.value;

            if (current == goal) {
                return reconstructPath(parent, current);
            }

            visited.add(current);

            for (int neighbor : graph.getOrDefault(current, Collections.emptyList())) {
                if (!visited.contains(neighbor)) {
                    parent.put(neighbor, current);
                    queue.offer(new Node(neighbor, heuristicValues.get(neighbor)));
                }
            }
        }

        return Collections.emptyList();
    }

    public static List<Integer> reconstructPath(Map<Integer, Integer> parent, int goal) {
        List<Integer> path = new ArrayList<>();
        while (parent.containsKey(goal)) {
            path.add(goal);
            goal = parent.get(goal);
        }
        path.add(goal);
        Collections.reverse(path);
        return path;
    }
}



/* BestFirstSSlidingPuzzle Informed strategies O(b^d).  f(n)=h(n) */
package akshay;
import java.util.*;

public class BestFirstSSlidingPuzzle {
    static void findZero(int[][] board, int[] pos) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == 0) {
                    pos[0] = i;
                    pos[1] = j;
                    return;
                }
            }
        }
    }

    static void printBoard(int[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                System.out.print(board[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    static void solve(int[][] initial, int[][] goal) {
        int[] dx = { 0, 0, -1, 1 };
        int[] dy = { 1, -1, 0, 0 };

        PriorityQueue<Map.Entry<int[][], Integer>> pq = new PriorityQueue<>(
                Comparator.comparingInt(entry -> entry.getValue()));

        Set<String> visited = new HashSet<>();
        pq.offer(new AbstractMap.SimpleEntry<>(initial, heuristic(initial, goal)));

        while (!pq.isEmpty()) {
            int[][] curr = pq.peek().getKey();
            int cost = pq.peek().getValue();
            pq.poll();

            String hash = Arrays.deepToString(curr);
            if (visited.contains(hash)) {
                continue;
            }

            visited.add(hash);

            printBoard(curr);

            if (Arrays.deepEquals(curr, goal)) {
                System.out.println("Goal State Reached");
                return;
            }

            int[] pos = new int[2];
            findZero(curr, pos);
            int x = pos[0];
            int y = pos[1];

            for (int i = 0; i < 4; i++) {
                int newX = x + dx[i];
                int newY = y + dy[i];

                if (newX >= 0 && newX < curr.length && newY >= 0 && newY < curr[0].length) {
                    int[][] newCurr = new int[curr.length][curr[0].length];
                    for (int r = 0; r < curr.length; r++) {
                        newCurr[r] = Arrays.copyOf(curr[r], curr[r].length);
                    }

                    int temp = newCurr[x][y];
                    newCurr[x][y] = newCurr[newX][newY];
                    newCurr[newX][newY] = temp;

                    int newCost = heuristic(newCurr, goal);
                    pq.offer(new AbstractMap.SimpleEntry<>(newCurr, newCost));
                }
            }
        }
    }

    static int heuristic(int[][] state, int[][] goal) {
        int distance = 0;
        for (int i = 0; i < state.length; i++) {
            for (int j = 0; j < state[0].length; j++) {
                if (state[i][j] != goal[i][j]) {
                    distance++;
                }
            }
        }
        return distance;
    }

    public static void main(String[] args) {
        int[][] initial = {
                { 2, 8, 3 },
                { 1, 6, 4 },
                { 7, 0, 5 } };

        int[][] goal = {
                { 1, 2, 3 },
                { 8, 0, 4 },
                { 7, 6, 5 } };

        solve(initial, goal);
    }
}

// AI TicTacToe (AI)

import java.util.Scanner;

public class TicTacToe {
    static char[][] board = {
        {' ', ' ', ' '},
        {' ', ' ', ' '},
        {' ', ' ', ' '}  
    };

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (true) {
            printBoard();
            playerMove(scanner);
            if (isGameOver()) {
                break;
            }
            aiMove();
            if (isGameOver()) {
                break;
            } 
        }
        scanner.close();
    }

    static void playerMove(Scanner scanner) {
        while (true) {
            System.out.println("Enter your move (row and column): ");
            int row = scanner.nextInt();
            int col = scanner.nextInt();
            if (row >= 0 && col >= 0 && row < 3 && col < 3 && board[row][col] == ' ') {
                board[row][col] = 'X';
                break;
            } else {
                System.out.println("This move is not valid");
            }
        }
    }

    static void aiMove() {
        int[] bestMove = findBestMove();
        board[bestMove[0]][bestMove[1]] = 'O';
    }

    static int[] findBestMove() {
        int bestScore = Integer.MIN_VALUE;
        int[] move = new int[2];

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == ' ') {
                    board[i][j] = 'O';
                    int score = minimax(board, 0, false);
                    board[i][j] = ' ';
                    if (score > bestScore) {
                        bestScore = score;
                        move[0] = i;
                        move[1] = j;
                    }
                }
            }
        }

        return move;
    }

    static int minimax(char[][] board, int depth, boolean isMaximizing) {
        char result = checkWinner();
        if (result != ' ') {
            return score(result);
        }

        if (isMaximizing) {
            int bestScore = Integer.MIN_VALUE;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (board[i][j] == ' ') {
                        board[i][j] = 'O';
                        int score = minimax(board, depth + 1, false);
                        board[i][j] = ' ';
                        bestScore = Math.max(score, bestScore);
                    }
                }
            }
            return bestScore;
        } else {
            int bestScore = Integer.MAX_VALUE;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (board[i][j] == ' ') {
                        board[i][j] = 'X';
                        int score = minimax(board, depth + 1, true);
                        board[i][j] = ' ';
                        bestScore = Math.min(score, bestScore);
                    }
                }
            }
            return bestScore;
        }
    }

    static int score(char result) {
        if (result == 'O') {
            return 1;
        } else if (result == 'X') {
            return -1;
        } else {
            return 0;
        }
    }

    static char checkWinner() {
        for (int i = 0; i < 3; i++) {
            if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != ' ') {
                return board[i][0];
            }
            if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != ' ') {
                return board[0][i];
            }
        }
        if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != ' ') {
            return board[0][0];
        }
        if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != ' ') {
            return board[0][2];
        }
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == ' ') {
                    return ' ';
                }
            }
        }
        return 'T'; // Tie
    }

    static boolean isGameOver() {
        char result = checkWinner();
        if (result == 'X') {
            printBoard();
            System.out.println("You win!");
            return true;
        } else if (result == 'O') {
            printBoard();
            System.out.println("AI wins!");
            return true;
        } else if (result == 'T') {
            printBoard();
            System.out.println("It's a tie!");
            return true;
        }
        return false;
    }

    static void printBoard() {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(board[i][j]);
                if (j < 2) {
                    System.out.print(" | ");
                }
            }
            System.out.println();
            if (i < 2) {
                System.out.println("----------");
            }
        }
    }
}


//AiTicTacToe 2 (akshay minmax )
import java.util.Scanner;

public class TicTacToe {
    static char[] board = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
    static char ai = 'O';
    static char human = 'X';

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int turn = 0;

        while (true) {
            displayBoard();

            if (checkWinner() != 'Y') {
                if (checkWinner() == 'X') {
                    System.out.println("--------------------YOU WON------------------");
                } else if (checkWinner() == 'O') {
                    System.out.println("-------------------AI WON------------------");
                } else if (checkWinner() == 'D') {
                    System.out.println("-------------------MATCH  DRAW---------------------");
                }
                break;
            } else {
                if (turn == 0) {
                    aiMove();
                    turn = 1;
                } else {
                    humanMove(scanner);
                    turn = 0;
                }
            }
        }
    }

    public static void displayBoard() {
        System.out.println("\n---------------------TIC-TAC-TOE---------------------------");
        System.out.println("\n---------------------AI VS YOU--------------------------\n");

        System.out.println("     |     |     ");
        System.out.println("  " + board[0] + "  |  " + board[1] + "  |  " + board[2] + " ");

        System.out.println("_____|_____|_____");
        System.out.println("     |     |     ");

        System.out.println("  " + board[3] + "  |  " + board[4] + "  |  " + board[5] + " ");

        System.out.println("_____|_____|_____");
        System.out.println("     |     |     ");

        System.out.println("  " + board[6] + "  |  " + board[7] + "  |  " + board[8] + " ");

        System.out.println("     |     |     \n");
    }

    public static char checkWinner() {
        for (int i = 0; i < 9; i += 3) {
            if (board[i] == board[i + 1] && board[i + 1] == board[i + 2]) {
                return board[i];
            }
        }

        for (int i = 0; i < 3; i++) {
            if (board[i] == board[i + 3] && board[i + 3] == board[i + 6]) {
                return board[i];
            }
        }

        if (board[0] == board[4] && board[4] == board[8]) {
            return board[0];
        }

        if (board[2] == board[4] && board[4] == board[6]) {
            return board[2];
        }

        int draw = 1;
        for (int i = 0; i < 9; i++) {
            if (board[i] != 'X' && board[i] != 'O') {
                draw = 0;
                break;
            }
        }
        if (draw == 1) {
            return 'D';
        }

        return 'Y';
    }

    public static int minimax(char player) {
        char result = checkWinner();

        if (result == ai) {
            return 1;
        } else if (result == human) {
            return -1;
        } else if (result == 'D') {
            return 0;
        }

        int bestScore;
        if (player == ai) {
            bestScore = Integer.MIN_VALUE;
            for (int i = 0; i < 9; i++) {
                if (board[i] != 'X' && board[i] != 'O') {
                    char ch = board[i];
                    board[i] = ai;
                    int score = minimax(human);
                    board[i] = ch;
                    bestScore = Math.max(score, bestScore);
                }
            }
        } else {
            bestScore = Integer.MAX_VALUE;
            for (int i = 0; i < 9; i++) {
                if (board[i] != 'X' && board[i] != 'O') {
                    char ch = board[i];
                    board[i] = human;
                    int score = minimax(ai);
                    board[i] = ch;
                    bestScore = Math.min(score, bestScore);
                }
            }
        }

        return bestScore;
    }

    public static void aiMove() {
        int bestScore = Integer.MIN_VALUE;
        int bestMove = -1;

        for (int i = 0; i <        9; i++) {
            if (board[i] != 'X' && board[i] != 'O') {
                char ch = board[i];
                board[i] = ai;
                int score = minimax(human);
                board[i] = ch;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = i;
                }
            }
        }

        board[bestMove] = ai;
    }

    public static void humanMove(Scanner scanner) {
        int move;
        do {
            System.out.print("Enter your move (1-9): ");
            move = scanner.nextInt();
            move--;

            if (move < 0 || move >= 9 || board[move] == 'X' || board[move] == 'O') {
                System.out.println("Enter a valid number.");
            }
        } while (move < 0 || move >= 9 || board[move] == 'X' || board[move] == 'O');

        board[move] = human;
    }
}







//  NON-AI TicTacToe

import java.util.Scanner;

public class NonAiTicTacToe {

    static int[] board = {0, 2, 2, 2, 2, 2, 2, 2, 2, 2};  // 2 represents empty, 3 represents X, 5 represents O

    static boolean checkWin(int player) {
        for (int i = 1; i <= 9; i += 3) {
            if (board[i] == player && board[i + 1] == player && board[i + 2] == player) {
                return true; // Win in a row
            }
        }

        for (int i = 1; i <= 3; i++) {
            if (board[i] == player && board[i + 3] == player && board[i + 6] == player) {
                return true; // Win in a column
            }
        }

        if (board[1] == player && board[5] == player && board[9] == player) {
            return true; // Win in the main diagonal
        }

        if (board[3] == player && board[5] == player && board[7] == player) {
            return true; // Win in the other diagonal
        }

        return false; // No win yet
    }

    // Function to check the possibility of winning for a player or machine
    static int posswin(int p) {
        int pos;
        for (int i = 1; i <= 9; i += 3) {  // Check rows
            pos = i;
            if (board[pos] * board[pos + 1] * board[pos + 2] == p * p * 2) {
                if (board[pos] == 2) return pos;
                if (board[pos + 1] == 2) return pos + 1;
                if (board[pos + 2] == 2) return pos + 2;
            }
        }

        for (int i = 1; i <= 3; i++) {  // Check columns
            pos = i;
            if (board[pos] * board[pos + 3] * board[pos + 6] == p * p * 2) {
                if (board[pos] == 2) return pos;
                if (board[pos + 3] == 2) return pos + 3;
                if (board[pos + 6] == 2) return pos + 6;
            }
        }

        pos = 1;
        if (board[pos] * board[pos + 4] * board[pos + 8] == p * p * 2) {
            if (board[pos] == 2) return pos;
            if (board[pos + 4] == 2) return pos + 4;
            if (board[pos + 8] == 2) return pos + 8;
        }

        pos = 3;
        if (board[pos] * board[pos + 2] * board[pos + 4] == p * p * 2) {
            if (board[pos] == 2) return pos;
            if (board[pos + 2] == 2) return pos + 2;
            if (board[pos + 4] == 2) return pos + 4;
        }

        return 0;
    }


    static void makemove(int player) {
        if (board[5] == 2) {
            board[5] = player;
            return;
        }

        int winningMove = posswin(player);
        if (winningMove != 0 && board[winningMove] == 2) {
            board[winningMove] = player;
            return;
        }

        int blockingMove = posswin(player == 3 ? 5 : 3);
        if (blockingMove != 0 && board[blockingMove] == 2) {
            board[blockingMove] = player;
            return;
        }

        int[] corners = {1, 3, 7, 9};
        for (int i = 0; i < 4; ++i) {
            if (board[corners[i]] == 2) {
                board[corners[i]] = player;
                return;
            }
        }

        for (int i = 1; i <= 9; ++i) {
            if (board[i] == 2) {
                board[i] = player;
                return;
            }
        }
    }

    static void displayBoard() {
        System.out.println();
        for (int i = 1; i <= 9; i++) {
            if (board[i] == 2) {
                System.out.print("_");
            } else if (board[i] == 3) {
                System.out.print("X");
            } else {
                System.out.print("O");
            }

            if (i % 3 == 0) {
                System.out.println();
            } else {
                System.out.print(" | ");
            }
        }
        System.out.println();
    }

    static int gameover() {
        if (checkWin(3)) {
            displayBoard();
            System.out.println("Game Over. You win!");
            return 1;
        }

        if (checkWin(5)) {
            displayBoard();
            System.out.println("Game Over. You lose!");
            return 1;
        }

        for (int i = 1; i <= 9; i++) {
            if (board[i] == 2) {
                return 0;  // Game is not over yet
            }
        }

        displayBoard();
        System.out.println("Game Over. It's a draw!");
        return 1;
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Welcome to Tic Tac Toe!");

        while (true) {
            displayBoard();

            int playerMove;
            System.out.print("Enter your move (1-9): ");
            playerMove = scanner.nextInt();
            if (playerMove < 1 || playerMove > 9 || board[playerMove] != 2) {
                System.out.println("Invalid move. Please choose a valid empty position.");
                continue;
            }
            board[playerMove] = 3;

            if (gameover() == 1) {
                break;
            }

            makemove(5);

            if (gameover() == 1) {
                break;
            }
        }

        scanner.close();
    }
}







// BFSWaterJug (uninfomred)


import java.util.*;
 
class Pair {
    int j1, j2;      
    List<Pair> path;  

    Pair(int j1, int j2)
    {
        this.j1 = j1;
        this.j2 = j2;
        path = new ArrayList<>();
    }
 
    Pair(int j1, int j2, List<Pair> _path)
    {
        this.j1 = j1;
        this.j2 = j2;
 
        path = new ArrayList<>();
        path.addAll(_path);
        path.add(new Pair(this.j1, this.j2));
    }
}
 
public class BFSWaterJug {
    public static void main(String[] args)
        throws java.lang.Exception
    {
        int jug1 = 4;
        int jug2 = 3;
        int target = 2;
 
        getPathIfPossible(jug1, jug2, target);
    }
 
    private static void
    getPathIfPossible(int jug1, int jug2, int target)
    {
        boolean[][] visited
            = new boolean[jug1 + 1][jug2 + 1];
        Queue<Pair> queue = new LinkedList<>();
 
        // Initial State: Both Jugs are empty so,
        // initialise j1 j2 as 0 and put it in the path list
        Pair initialState = new Pair(0, 0);
        initialState.path.add(new Pair(0, 0));
        queue.offer(initialState);
 
        while (!queue.isEmpty()) {
            Pair curr = queue.poll();
 
            // Skip already visited states and overflowing
            // water states
            if (curr.j1 > jug1 || curr.j2 > jug2
                || visited[curr.j1][curr.j2])
                continue;
            // mark current jugs state as visited
            visited[curr.j1][curr.j2] = true;
 
            // Check if current state has already reached
            // the target amount of water or not
            if (curr.j1 == target || curr.j2 == target) {
                if (curr.j1 == target) {
                    // If in our current state, jug1 holds
                    // the required amount of water, then we
                    // empty the jug2 and push it into our
                    // path.
                    curr.path.add(new Pair(curr.j1, 0));
                }
                else {
                    // else, If in our current state, jug2
                    // holds the required amount of water,
                    // then we empty the jug1 and push it
                    // into our path.
                    curr.path.add(new Pair(0, curr.j2));
                }
                int n = curr.path.size();
                System.out.println(
                    "Path of states of jugs followed is :");
                for (int i = 0; i < n; i++)
                    System.out.println(
                        curr.path.get(i).j1 + " , "
                        + curr.path.get(i).j2);
                return;
            }
 
            // If we have not yet found the target, then we
            // have three cases left I. Fill the jug and
            // Empty the other II. Fill the jug and let the
            // other remain untouched III. Empty the jug and
            // let the other remain untouched
            // IV. Transfer amounts from one jug to another
 
            // Please refer to the table attached above to
            // understand the cases that we are taking into
            // consideration
 
            // Now,
            // I. Fill the jug and Empty the other
            queue.offer(new Pair(jug1, 0, curr.path));
            queue.offer(new Pair(0, jug2, curr.path));
 
            // II. Fill the jug and let the other remain
            // untouched
            queue.offer(new Pair(jug1, curr.j2, curr.path));
            queue.offer(new Pair(curr.j1, jug2, curr.path));
 
            // III. Empty the jug and let the other remain
            // untouched
            queue.offer(new Pair(0, curr.j2, curr.path));
            queue.offer(new Pair(curr.j1, 0, curr.path));
 
            // IV. Transfer water from one to another until
            // one jug becomes empty or until one jug
            // becomes full in this process
 
            // Transferring water form jug1 to jug2
            int emptyJug = jug2 - curr.j2;
            int amountTransferred
                = Math.min(curr.j1, emptyJug);
            int j2 = curr.j2 + amountTransferred;
            int j1 = curr.j1 - amountTransferred;
            queue.offer(new Pair(j1, j2, curr.path));
 
            // Tranferring water form jug2 to jug1
            emptyJug = jug1 - curr.j1;
            amountTransferred = Math.min(curr.j2, emptyJug);
            j2 = curr.j2 - amountTransferred;
            j1 = curr.j1 + amountTransferred;
            queue.offer(new Pair(j1, j2, curr.path));
        }
 
        System.out.println("Not Possible to obtain target");
    }
}








//DFS Water Jug (uninfomred)

import java.util.*;

public class DFSWaterJug {

    public static int total = 0;

    static class Node {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static Stack<Node> result = new Stack<Node>();
    static boolean[][] m = new boolean[5][5];
    static int found = 0;

    static boolean solveDFS(int curj1, int curj2, int jug1, int jug2, int tx, int ty) {

        // Got final case
        if (curj1 == tx && curj2 == ty) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        total++;

        // If the node is already visited
        if (m[curj1][curj2]) {
            return false;
        }
        // Marks the node as a visited
        m[curj1][curj2] = true;

        // Fill the 1st jug completely
        if (curj1 < jug1 && solveDFS(jug1, curj2, jug1, jug2, tx, ty)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        // Fill the 2nd jug completely
        if (curj2 < jug2 && solveDFS(curj1, jug2, jug1, jug2, tx, ty)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        //Empty the first jug
        if (curj1 > 0 && solveDFS(0, curj2, jug1, jug2, tx, ty)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        // Empty the second jug
        if (curj2 > 0 && solveDFS(curj1, 0, jug1, jug2, tx, ty)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        
        if (curj1 > 0 && curj2 < jug2) {
            boolean temp;
            if (curj2 + curj1 <= jug2) {
                // Empty first jug into second jug
                temp = solveDFS(0, curj1 + curj2, jug1, jug2, tx, ty);
            } else {
                // Pour the water from 1st jug to 2nd jug
                temp = solveDFS(curj1 - (jug2 - curj2), jug2, jug1, jug2, tx, ty);
            }
            if (temp) {
                result.push(new Node(curj1, curj2));
                return true;
            }
        }

        if (curj2 > 0 && curj1 < jug1
                && solveDFS(Math.min(curj1 + curj2, jug1), curj2 - Math.min(jug1, curj2), jug1, jug2, tx, ty)) {
            boolean temp;

            if (curj2 + curj1 <= jug1) {
                // Empty the second jug into first jug
                temp = solveDFS(curj1 + curj2, 0, jug1, jug2, tx, ty);
            } else {
                // Pour the water from second jug to first j
                temp = solveDFS(jug1, curj2 - (jug1 - curj2), jug1, jug2, tx, ty);
            }
            if (temp) {
                result.push(new Node(curj1, curj2));
                return true;
            }
        }
        m[curj1][curj2] = false;
        return false;
    }

    // function to print the stack in reverse order
    public static void printReverseStack(Stack<Node> stack) {
        // base case
        if (stack.isEmpty())
            return;

        // create temporary stack
        Stack<Node> temporaryStack = new Stack<>();

        // copy all the elements from given stack to temporary stack
        while (stack.size() > 0) {
            temporaryStack.push(stack.pop());
        }

        for (Node n : temporaryStack) {
            System.out.println("(" + n.x + "," + n.y + ")");
        }
    }

    public static void main(String[] args) {

        DFSWaterJug obj = new DFSWaterJug();
        boolean res = solveDFS(0, 0, 4, 3, 2, 0);
        printReverseStack(result);
        System.out.println("Total Nodes: " + total);

    }
}










// Best first Search 8 puzzle (informed)


import java.util.*;

public class EightPuzzleBestFirst {
    static class State {
        int[][] board;
        int x;
        int y;
        int heuristic;
        State parent;

        State(int[][] board, int x, int y, int heuristic, State parent) {
            this.board = new int[3][3];
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    this.board[i][j] = board[i][j];
                }
            }
            this.x = x;
            this.y = y;
            this.heuristic = heuristic;
            this.parent = parent;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            State state = (State) o;
            return Arrays.deepEquals(board, state.board);
        }

        @Override
        public int hashCode() {
            return Arrays.deepHashCode(board);
        }
    }

    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) {
        // Hardcoded initial state
        int[][] initialStateBoard = {
            {1, 0, 3},
            {4, 2, 6},
            {7, 5, 8}
        };

        // Hardcoded goal state
        int[][] goalStateBoard = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 0}
        };

        PriorityQueue<State> pq = new PriorityQueue<>(new Comparator<State>() {
            @Override
            public int compare(State o1, State o2) {
                return o1.heuristic - o2.heuristic;
            }
        });

        int[] pos = new int[2];
        find_zero(initialStateBoard, pos);
        State initialState = new State(initialStateBoard, pos[0], pos[1], Manhattan(initialStateBoard), null);
        pq.add(initialState);

        State goalState = null;

        while (!pq.isEmpty()) {
            State cur = pq.poll();
            int[][] board = cur.board;

            if (Arrays.deepEquals(board, goalStateBoard)) {
                goalState = cur;
                break;
            }

            find_zero(board, pos);
            int x = pos[0];
            int y = pos[1];
            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];
                if (nx >= 0 && nx < 3 && ny >= 0 && ny < 3) {
                    int[][] new_board = new int[3][3];
                    for (int i = 0; i < 3; i++) {
                        for (int j = 0; j < 3; j++) {
                            new_board[i][j] = board[i][j];
                        }
                    }
                    new_board[x][y] = new_board[nx][ny];
                    new_board[nx][ny] = 0;
                    var newState = new State(new_board, nx, ny, Manhattan(new_board), cur);
                    pq.add(newState);
                }
            }
        }

        if (goalState != null) {
            Stack<State> path = new Stack<>();
            State currentState = goalState;
            while (currentState != null) {
                path.push(currentState);
                currentState = currentState.parent;
            }

            while (!path.isEmpty()) {
                State state = path.pop();
                printArr(state.board);
            }
        } else {
            System.out.println("No solution found.");
        }
    }

    static void printArr(int[][] arr) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    static void find_zero(int[][] arr, int[] pos) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (arr[i][j] == 0) {
                    pos[0] = i;
                    pos[1] = j;
                    return;
                }
            }
        }
    }

    static int Manhattan(int[][] arr) {
        int ans = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (arr[i][j] == 0) continue;
                int y = (arr[i][j] - 1) % 3;
                int x = (arr[i][j] - 1) / 3;
                ans += Math.abs(x - i) + Math.abs(y - j);
            }
        }
        return ans;
    }
}








//BFS & DFS Monkey Banana Problem

import java.util.*;

class State {
    int monkeyPosition;
    int chairPosition;
    int bananaPosition;

    State(int monkeyPosition, int chairPosition, int bananaPosition) {
        this.monkeyPosition = monkeyPosition;
        this.chairPosition = chairPosition;
        this.bananaPosition = bananaPosition;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || getClass() != obj.getClass())
            return false;
        State state = (State) obj;
        return monkeyPosition == state.monkeyPosition &&
                chairPosition == state.chairPosition &&
                bananaPosition == state.bananaPosition;
    }

    @Override
    public int hashCode() {
        return Objects.hash(monkeyPosition, chairPosition, bananaPosition);
    }
}

public class MonkeyBananaProblem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter initial position for Monkey (0 or 1 or 2):");
        int initialMonkeyPosition = scanner.nextInt();

        System.out.println("Enter initial position for Chair (0 or 1):");
        int initialChairPosition = scanner.nextInt();

        System.out.println("Enter initial position for Banana (0 or 1 or 2):");
        int initialBananaPosition = scanner.nextInt();

        State initialState = new State(initialMonkeyPosition, initialChairPosition, initialBananaPosition);

        System.out.println("Choose algorithm: (1) BFS, (2) DFS");
        int choice = scanner.nextInt();

        switch (choice) {
            case 1:
                System.out.println("BFS Solution:");
                bfs(initialState);
                break;
            case 2:
                System.out.println("DFS Solution:");
                dfs(initialState, new HashSet<>());
                break;
            default:
                System.out.println("Invalid choice.");
        }
    }

    public static void bfs(State initialState) {
        Queue<State> queue = new LinkedList<>();
        Set<State> visited = new HashSet<>();

        queue.add(initialState);
        visited.add(initialState);

        while (!queue.isEmpty()) {
            State currentState = queue.poll();
            if (isGoalState(currentState)) {
                printSolution(currentState);
                return;
            }

            List<State> nextStates = generateNextStates(currentState);
            for (State nextState : nextStates) {
                if (!visited.contains(nextState)) {
                    queue.add(nextState);
                    visited.add(nextState);
                }
            }
        }

        System.out.println("No solution found.");
    }

    public static void dfs(State currentState, Set<State> visited) {
        if (isGoalState(currentState)) {
            printSolution(currentState);
            return;
        }

        visited.add(currentState);
        List<State> nextStates = generateNextStates(currentState);

        for (State nextState : nextStates) {
            if (!visited.contains(nextState)) {
                dfs(nextState, visited);
            }
        }
    }

    public static boolean isGoalState(State state) {
        return state.monkeyPosition == state.bananaPosition;
    }

    public static List<State> generateNextStates(State currentState) {
        List<State> nextStates = new ArrayList<>();

        // Monkey moves
        if (currentState.monkeyPosition < 2) {
            nextStates.add(new State(currentState.monkeyPosition + 1, currentState.chairPosition,
                    currentState.bananaPosition));
        }

        if (currentState.monkeyPosition > 0) {
            nextStates.add(new State(currentState.monkeyPosition - 1, currentState.chairPosition,
                    currentState.bananaPosition));
        }

        // Chair moves
        nextStates.add(
                new State(currentState.monkeyPosition, 1 - currentState.chairPosition, currentState.bananaPosition));

        // Monkey climbs the chair
        if (currentState.monkeyPosition == currentState.chairPosition
                && currentState.monkeyPosition == currentState.bananaPosition) {
            nextStates
                    .add(new State(currentState.chairPosition, currentState.chairPosition, currentState.chairPosition));
        }

        return nextStates;
    }

    public static void printSolution(State state) {
        System.out.println("Monkey reached the banana successfully!");
        System.out.println("Monkey Position: " + state.monkeyPosition);
        System.out.println("Chair Position: " + state.chairPosition);
        System.out.println("Banana Position: " + state.bananaPosition);
    }
}










// DLS Depth Limited Search Algorithm Water Jug

import java.util.*;

public class DLSWaterJug {

    public static int total = 0;

    static class Node {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static Stack<Node> result = new Stack<Node>();
    static boolean[][] m = new boolean[5][5];
    static int found = 0;

    static boolean solveDLS(int curj1, int curj2, int jug1, int jug2, int tx, int ty, int depth, int limit) {

        // Got final case
        if (curj1 == tx && curj2 == ty) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        total++;

        // If the depth limit is reached
        if (depth > limit) {
            return false;
        }

        // If the node is already visited
        if (m[curj1][curj2]) {
            return false;
        }
        // Marks the node as a visited
        m[curj1][curj2] = true;

        // Fill the 1st jug completely
        if (curj1 < jug1 && solveDLS(jug1, curj2, jug1, jug2, tx, ty, depth + 1, limit)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        // Fill the 2nd jug completely
        if (curj2 < jug2 && solveDLS(curj1, jug2, jug1, jug2, tx, ty, depth + 1, limit)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        // Empty the first jug
        if (curj1 > 0 && solveDLS(0, curj2, jug1, jug2, tx, ty, depth + 1, limit)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        // Empty the second jug
        if (curj2 > 0 && solveDLS(curj1, 0, jug1, jug2, tx, ty, depth + 1, limit)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        if (curj1 > 0 && curj2 < jug2) {
            boolean temp;
            if (curj2 + curj1 <= jug2) {
                // Empty first jug into second jug
                temp = solveDLS(0, curj1 + curj2, jug1, jug2, tx, ty, depth + 1, limit);
            } else {
                // Pour the water from 1st jug to 2nd jug
                temp = solveDLS(curj1 - (jug2 - curj2), jug2, jug1, jug2, tx, ty, depth + 1, limit);
            }
            if (temp) {
                result.push(new Node(curj1, curj2));
                return true;
            }
        }

        if (curj2 > 0 && curj1 < jug1) {
            boolean temp;
            if (curj2 + curj1 <= jug1) {
                // Empty the second jug into first jug
                temp = solveDLS(curj1 + curj2, 0, jug1, jug2, tx, ty, depth + 1, limit);
            } else {
                // Pour the water from second jug to first jug
                temp = solveDLS(jug1, curj2 - (jug1 - curj2), jug1, jug2, tx, ty, depth + 1, limit);
            }
            if (temp) {
                result.push(new Node(curj1, curj2));
                return true;
            }
        }

        m[curj1][curj2] = false;
        return false;
    }

    // function to print the stack in reverse order
    public static void printReverseStack(Stack<Node> stack) {
        // base case
        if (stack.isEmpty())
            return;

        // create temporary stack
        Stack<Node> temporaryStack = new Stack<>();

        // copy all the elements from given stack to temporary stack
        while (stack.size() > 0) {
            temporaryStack.push(stack.pop());
        }

        for (Node n : temporaryStack) {
            System.out.println("(" + n.x + "," + n.y + ")");
        }
    }

    public static void main(String[] args) {
        DLSWaterJug obj = new DLSWaterJug();
        int depthLimit = 5; // Set a reasonable depth limit
        boolean res = solveDLS(0, 0, 4, 3, 2, 0, 0, depthLimit);
        if (res) {
            printReverseStack(result);
        } else {
            System.out.println("Solution not found within depth limit.");
        }
        System.out.println("Total Nodes: " + total);
    }
}






// iterative deepning search (IDS) water jug problem

import java.util.*;

public class IDDFSWaterJug {

    static class Node {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static boolean[][] visited = new boolean[5][5];
    static Stack<Node> result = new Stack<Node>();
    static int totalNodesVisited = 0;

    // Depth-limited DFS
    static boolean solveDFS(int curj1, int curj2, int jug1, int jug2, int tx, int ty, int depth) {
        if (curj1 == tx && curj2 == ty) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        if (depth == 0)
            return false;

        visited[curj1][curj2] = true;
        totalNodesVisited++;

        if (curj1 < jug1 && solveDFS(jug1, curj2, jug1, jug2, tx, ty, depth - 1)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        if (curj2 < jug2 && solveDFS(curj1, jug2, jug1, jug2, tx, ty, depth - 1)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        if (curj1 > 0 && solveDFS(0, curj2, jug1, jug2, tx, ty, depth - 1)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        if (curj2 > 0 && solveDFS(curj1, 0, jug1, jug2, tx, ty, depth - 1)) {
            result.push(new Node(curj1, curj2));
            return true;
        }

        if (curj1 > 0 && curj2 < jug2) {
            boolean temp;
            if (curj2 + curj1 <= jug2) {
                temp = solveDFS(0, curj1 + curj2, jug1, jug2, tx, ty, depth - 1);
            } else {
                temp = solveDFS(curj1 - (jug2 - curj2), jug2, jug1, jug2, tx, ty, depth - 1);
            }
            if (temp) {
                result.push(new Node(curj1, curj2));
                return true;
            }
        }

        if (curj2 > 0 && curj1 < jug1
                && solveDFS(Math.min(curj1 + curj2, jug1), curj2 - Math.min(jug1, curj2), jug1, jug2, tx, ty, depth - 1)) {
            boolean temp;
            if (curj2 + curj1 <= jug1) {
                temp = solveDFS(curj1 + curj2, 0, jug1, jug2, tx, ty, depth - 1);
            } else {
                temp = solveDFS(jug1, curj2 - (jug1 - curj2), jug1, jug2, tx, ty, depth - 1);
            }
            if (temp) {
                result.push(new Node(curj1, curj2));
                return true;
            }
        }

        return false;
    }

    static boolean iterativeDeepeningDFS(int jug1, int jug2, int tx, int ty, int maxDepth) {
        for (int depth = 0; depth <= maxDepth; depth++) {
            if (solveDFS(0, 0, jug1, jug2, tx, ty, depth)) {
                return true;
            }
            clearVisited();
        }
        return false;
    }

    static void clearVisited() {
        for (int i = 0; i < visited.length; i++) {
            Arrays.fill(visited[i], false);
        }
    }

    // function to print the stack in reverse order
    public static void printReverseStack(Stack<Node> stack) {
        // base case
        if (stack.isEmpty())
            return;

        // create temporary stack
        Stack<Node> temporaryStack = new Stack<>();

        // copy all the elements from given stack to temporary stack
        while (stack.size() > 0) {
            temporaryStack.push(stack.pop());
        }

        for (Node n : temporaryStack) {
            System.out.println("(" + n.x + "," + n.y + ")");
        }
    }

    public static void main(String[] args) {
        IDDFSWaterJug obj = new IDDFSWaterJug();
        boolean res = iterativeDeepeningDFS(4, 3, 2, 0, 10); // Adjust maxDepth as needed
        if (res) {
            printReverseStack(result);
        } else {
            System.out.println("No solution found within depth limit.");
        }
        System.out.println("Total Nodes Visited: " + totalNodesVisited);
    }
}









// EightPuzzle A Star

import java.util.*;

public class EightPuzzleAStar {
    static class State {
        int[][] board;
        int x;
        int y;
        int cost;
        int depth;
        State parent;

        State(int[][] board, int x, int y, int cost, int depth, State parent) {
            this.board = new int[3][3];
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    this.board[i][j] = board[i][j];
                }
            }
            this.x = x;
            this.y = y;
            this.cost = cost;
            this.depth = depth;
            this.parent = parent;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            State state = (State) o;
            return Arrays.deepEquals(board, state.board);
        }

        @Override
        public int hashCode() {
            return Arrays.deepHashCode(board);
        }
    }

    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) {
        // Hardcoded initial state
        int[][] initialStateBoard = {
            {1, 0, 3},
            {4, 2, 6},
            {7, 5, 8}
        };

        // Hardcoded goal state
        int[][] goalStateBoard = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 0}
        };

        PriorityQueue<State> pq = new PriorityQueue<>(new Comparator<State>() {
            @Override
            public int compare(State o1, State o2) {
                return o1.cost - o2.cost;
            }
        });

        int[] pos = new int[2];
        find_zero(initialStateBoard, pos);
        State initialState = new State(initialStateBoard, pos[0], pos[1], Manhattan(initialStateBoard), 0, null);
        pq.add(initialState);

        State goalState = null;

        while (!pq.isEmpty()) {
            State cur = pq.poll();
            int[][] board = cur.board;

            if (Arrays.deepEquals(board, goalStateBoard)) {
                goalState = cur;
                break;
            }

            find_zero(board, pos);
            int x = pos[0];
            int y = pos[1];
            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];
                if (nx >= 0 && nx < 3 && ny >= 0 && ny < 3) {
                    int[][] new_board = new int[3][3];
                    for (int i = 0; i < 3; i++) {
                        for (int j = 0; j < 3; j++) {
                            new_board[i][j] = board[i][j];
                        }
                    }
                    new_board[x][y] = new_board[nx][ny];
                    new_board[nx][ny] = 0;
                    var newState = new State(new_board, nx, ny, Manhattan(new_board) + cur.depth + 1, cur.depth + 1, cur);
                    pq.add(newState);
                }
            }
        }

        if (goalState != null) {
            Stack<State> path = new Stack<>();
            State currentState = goalState;
            while (currentState != null) {
                path.push(currentState);
                currentState = currentState.parent;
            }

            while (!path.isEmpty()) {
                State state = path.pop();
                printArr(state.board);
            }
        } else {
            System.out.println("No solution found.");
        }
    }

    static void printArr(int[][] arr) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    static void find_zero(int[][] arr, int[] pos) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (arr[i][j] == 0) {
                    pos[0] = i;
                    pos[1] = j;
                    return;
                }
            }
        }
    }

    static int Manhattan(int[][] arr) {
        int ans = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (arr[i][j] == 0) continue;
                int y = (arr[i][j] - 1) % 3;
                int x = (arr[i][j] - 1) / 3;
                ans += Math.abs(x - i) + Math.abs(y - j);
            }
        }
        return ans;
    }
}







// Shortest Path best first search

import java.util.*;

public class Main {
    private static class Node implements Comparable<Node> {
        String name;
        Map<Node, Integer> neighbours = new HashMap<>();
        int heuristic; // Straight-line distance to Bucharest
        Node parent;

        Node(String name, int heuristic) {
            this.name = name;
            this.heuristic = heuristic;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.heuristic, other.heuristic);
        }

        @Override
        public String toString() {
            return name + " (h=" + heuristic + ")";
        }
    }

    private Map<String, Node> nodes = new HashMap<>();
    private Node start;
    private Node goal;

    public Main(String startName, String goalName) {
        this.start = new Node(startName, 366); // Heuristic for Arad
        this.goal = new Node(goalName, 0); // Heuristic for Bucharest
        nodes.put(startName, start);
        nodes.put(goalName, goal);
    }

    public void addEdge(String sourceName, String destName, int distance, int destHeuristic) {
        Node source = nodes.get(sourceName);
        Node dest = nodes.computeIfAbsent(destName, k -> new Node(k, destHeuristic));
        source.neighbours.put(dest, distance);
    }

    public List<String> findPath() {
        PriorityQueue<Node> openList = new PriorityQueue<>();
        Set<Node> closedList = new HashSet<>();
        openList.add(start);

        while (!openList.isEmpty()) {
            Node current = openList.poll();
            System.out.println("Processing node: " + current);

            if (current.equals(goal)) {
                return constructPath(current);
            }
            closedList.add(current);

            for (Map.Entry<Node, Integer> entry : current.neighbours.entrySet()) {
                Node neighbour = entry.getKey();
                if (!closedList.contains(neighbour)) {
                    neighbour.parent = current;
                    openList.add(neighbour);
                    System.out.println("Added to open list: " + neighbour);
                }
            }

            System.out.println("Open list: " + openList);
            System.out.println("Closed list: " + closedList);
        }
        return null; // No path found
    }

    private List<String> constructPath(Node node) {
        LinkedList<String> path = new LinkedList<>();
        while (node != null) {
            path.addFirst(node.name);
            node = node.parent;
        }
        return path;
    }

    public static void main(String[] args) {
        Main bfs = new Main("Arad", "Bucharest");
        bfs.addEdge("Arad", "Zerind", 75, 374);
        bfs.addEdge("Arad", "Timisoara", 118, 329);
        bfs.addEdge("Arad", "Sibiu", 140, 253);
        bfs.addEdge("Zerind", "Oradea", 71, 380);
        bfs.addEdge("Oradea", "Sibiu", 151, 253);
        bfs.addEdge("Timisoara", "Lugoj", 111, 244);
        bfs.addEdge("Lugoj", "Mehadia", 70, 241);
        bfs.addEdge("Mehadia", "Drobeta", 75, 242);
        bfs.addEdge("Drobeta", "Craiova", 120, 160);
        bfs.addEdge("Craiova", "Rimnicu Vilcea", 146, 193);
        bfs.addEdge("Craiova", "Pitesti", 138, 98);
        bfs.addEdge("Sibiu", "Fagaras", 99, 178);
        bfs.addEdge("Sibiu", "Rimnicu Vilcea", 80, 193);
        bfs.addEdge("Rimnicu Vilcea", "Pitesti", 97, 98);
        bfs.addEdge("Fagaras", "Bucharest", 211, 0);
        bfs.addEdge("Pitesti", "Bucharest", 101, 0);
        bfs.addEdge("Bucharest", "Urziceni", 85, 80);
        bfs.addEdge("Bucharest", "Giurgiu", 90, 77);
        bfs.addEdge("Urziceni", "Vaslui", 142, 199);
        bfs.addEdge("Vaslui", "Iasi", 92, 226);
        bfs.addEdge("Iasi", "Neamt", 87, 234);
        bfs.addEdge("Urziceni", "Hirsova", 98, 151);
        bfs.addEdge("Hirsova", "Eforie", 86, 161);

        List<String> path = bfs.findPath();
        if (path != null) {
            System.out.println("Path: " + path);
        } else {
            System.out.println("No path found.");
        }
    }
}







// shortest path A star

import java.util.*;

public class Main {
    private static class Node implements Comparable<Node> {
        String name;
        Map<Node, Integer> neighbours = new HashMap<>();
        int g; // Cost from start to this node
        int h; // Heuristic cost from this node to goal
        Node parent;

        Node(String name, int h) {
            this.name = name;
            this.h = h;
            this.g = Integer.MAX_VALUE;
        }

        int f() {
            return g + h;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.f(), other.f());
        }

        @Override
        public String toString() {
            return name + " (g=" + g + ", h=" + h + ", f=" + f() + ")";
        }
    }

    private Map<String, Node> nodes = new HashMap<>();
    private Node start;
    private Node goal;

    public Main(String startName, String goalName) {
        this.start = new Node(startName, 366); // Heuristic for Arad
        this.goal = new Node(goalName, 0); // Heuristic for Bucharest
        nodes.put(startName, start);
        nodes.put(goalName, goal);
    }

    public void addEdge(String sourceName, String destName, int distance, int destHeuristic) {
        Node source = nodes.get(sourceName);
        Node dest = nodes.computeIfAbsent(destName, k -> new Node(k, destHeuristic));
        source.neighbours.put(dest, distance);
    }

    public List<String> findPath() {
        PriorityQueue<Node> openList = new PriorityQueue<>();
        Set<Node> closedList = new HashSet<>();
        start.g = 0;
        openList.add(start);

        while (!openList.isEmpty()) {
            Node current = openList.poll();
            System.out.println("Processing node: " + current);

            if (current.equals(goal)) {
                return constructPath(current);
            }
            closedList.add(current);

            for (Map.Entry<Node, Integer> entry : current.neighbours.entrySet()) {
                Node neighbour = entry.getKey();
                int tentativeG = current.g + entry.getValue();

                if (tentativeG < neighbour.g) {
                    neighbour.parent = current;
                    neighbour.g = tentativeG;
                    if (!openList.contains(neighbour) && !closedList.contains(neighbour)) {
                        openList.add(neighbour);
                        System.out.println("Added to open list: " + neighbour);
                    } else if (openList.contains(neighbour)) {
                        openList.remove(neighbour);
                        openList.add(neighbour);
                        System.out.println("Updated node in open list: " + neighbour);
                    }
                }
            }

            System.out.println("Open list: " + openList);
            System.out.println("Closed list: " + closedList);
        }
        return null; // No path found
    }

    private List<String> constructPath(Node node) {
        LinkedList<String> path = new LinkedList<>();
        while (node != null) {
            path.addFirst(node.name);
            node = node.parent;
        }
        return path;
    }

    public static void main(String[] args) {
        Main astar = new Main("Arad", "Bucharest");
        astar.addEdge("Arad", "Zerind", 75, 374);
        astar.addEdge("Arad", "Timisoara", 118, 329);
        astar.addEdge("Arad", "Sibiu", 140, 253);
        astar.addEdge("Zerind", "Oradea", 71, 380);
        astar.addEdge("Oradea", "Sibiu", 151, 253);
        astar.addEdge("Timisoara", "Lugoj", 111, 244);
        astar.addEdge("Lugoj", "Mehadia", 70, 241);
        astar.addEdge("Mehadia", "Drobeta", 75, 242);
        astar.addEdge("Drobeta", "Craiova", 120, 160);
        astar.addEdge("Craiova", "Rimnicu Vilcea", 146, 193);
        astar.addEdge("Craiova", "Pitesti", 138, 98);
        astar.addEdge("Sibiu", "Fagaras", 99, 178);
        astar.addEdge("Sibiu", "Rimnicu Vilcea", 80, 193);
        astar.addEdge("Rimnicu Vilcea", "Pitesti", 97, 98);
        astar.addEdge("Fagaras", "Bucharest", 211, 0);
        astar.addEdge("Pitesti", "Bucharest", 101, 0);
        astar.addEdge("Bucharest", "Urziceni", 85, 80);
        astar.addEdge("Bucharest", "Giurgiu", 90, 77);
        astar.addEdge("Urziceni", "Vaslui", 142, 199);
        astar.addEdge("Vaslui", "Iasi", 92, 226);
        astar.addEdge("Iasi", "Neamt", 87, 234);
        astar.addEdge("Urziceni", "Hirsova", 98, 151);
        astar.addEdge("Hirsova", "Eforie", 86, 161);

        // ... add other edges with their respective heuristics ...

        List<String> path = astar.findPath();
        if (path != null) {
            System.out.println("Path: " + path);
        } else {
            System.out.println("No path found.");
        }
    }
}








// N Queens CSP
import java.util.*;

class NQueensAlgo {
    static final int N = 4;

    static class State {
        int[] board;
        int level;
        List<State> successors;  
        boolean isSolved;       
                                 
        State(int[] board, int level) {
            this.board = board.clone();
            this.level = level;
            this.successors = new ArrayList<>();
            this.isSolved = false;
        }

        List<State> generateSuccessors() {
            List<State> successors = new ArrayList<>();
            if (level < N) {
                for (int col = 0; col < N; col++) {
                    if (isSafe(board, level, col)) {
                        board[level] = col;
                        successors.add(new State(board, level + 1));
                    }
                }
            }
            return successors;
        }

        boolean isGoal() {
            return level == N;
        }

        boolean isSafe(int[] board, int row, int col) {
            for (int i = 0; i < row; i++) {
                if (board[i] == col || Math.abs(board[i] - col) == row - i) {
                    return false;
                }
            }
            return true;
        }

        void printBoard() {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (board[i] == j) {
                        System.out.print("Q ");
                    } else {
                        System.out.print(". ");
                    }
                }
                System.out.println();
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        NQueensAlgo solver = new NQueensAlgo();
        int[] initialBoard = new int[N];
        Arrays.fill(initialBoard, -1);
        State initial = new State(initialBoard, 0);
        solver.aoStar(initial);
    }

    void aoStar(State initialState) {
        PriorityQueue<State> open = new PriorityQueue<>(Comparator.comparingInt(this::heuristic));
        Set<State> closed = new HashSet<>();
        open.add(initialState);

        while (!open.isEmpty()) {
            State current = open.poll();
            if (current.isGoal()) {
                System.out.println("Solution found:");
                current.printBoard();
                return;
            }

            closed.add(current);
            List<State> successors = current.generateSuccessors();
            current.successors = successors;  // Link successors

            for (State successor : successors) {
                if (!closed.contains(successor) && !open.contains(successor)) {
                    open.add(successor);
                    System.out.println("Intermediate step:");
                    successor.printBoard();
                }
            }

            // Handle "AND" conditions
            if (current.successors.stream().allMatch(s -> s.isSolved)) {
                current.isSolved = true;
            }
        }

        System.out.println("No solution found.");
    }

    int heuristic(State state) {
        return N - state.level;
    }
}








//AO* 


import java.util.*;

public class AO {
public static Map<String, Integer>
	Cost(Map<String, Integer> H,
		Map<String, List<String> > condition, int weight)
{
	Map<String, Integer> cost = new HashMap<>();
	if (condition.containsKey("AND")) {
	List<String> AND_nodes = condition.get("AND");
	String Path_A = String.join(" AND ", AND_nodes);
	int PathA
		= AND_nodes.stream()
		.mapToInt(
		node -> H.get(node) + weight)
		.sum();
	cost.put(Path_A, PathA);
	}
	if (condition.containsKey("OR")) {
	List<String> OR_nodes = condition.get("OR");
	String Path_B = String.join(" OR ", OR_nodes);
	int PathB
		= OR_nodes.stream()
		.mapToInt(
		node -> H.get(node) + weight)
		.min()
		.getAsInt();
	cost.put(Path_B, PathB);
	}
	return cost;
}

public static Map<String, Map<String, Integer> >
	UpdateCost(
	Map<String, Integer> H,
	Map<String, Map<String, List<String> > > Conditions,
	int weight)
{
	List<String> Main_nodes
	= new ArrayList<>(Conditions.keySet());
	Collections.reverse(Main_nodes);
	Map<String, Map<String, Integer> > least_cost
	= new HashMap<>();
	for (String key : Main_nodes) {
	Map<String, List<String> > condition
		= Conditions.get(key);
	System.out.printf("%s: %s >>> %s%n", key,
						condition,
						Cost(H, condition, weight));
	Map<String, Integer> c
		= Cost(H, condition, weight);
	H.put(key, Collections.min(c.values()));
	least_cost.put(key, Cost(H, condition, weight));
	}
	return least_cost;
}

public static String ShortestPath(
	String Start,
	Map<String, Map<String, Integer> > Updated_cost,
	Map<String, Integer> H)
{
	String Path = Start;
	if (Updated_cost.containsKey(Start)) {
	int Min_cost = Collections.min(
		Updated_cost.get(Start).values());
	List<String> key = new ArrayList<>(
		Updated_cost.get(Start).keySet());
	List<Integer> values = new ArrayList<>(
		Updated_cost.get(Start).values());
	int Index = values.indexOf(Min_cost);
	List<String> Next
		= Arrays.asList(key.get(Index).split(" "));
	if (Next.size() == 1) {
		Start = Next.get(0);
		Path += "<--"
		+ ShortestPath(Start, Updated_cost,
						H);
	}
	else {
		Path += "<--(" + key.get(Index) + ") ";
		Start = Next.get(0);
		Path += "["
		+ ShortestPath(Start, Updated_cost,
						H)
		+ " + ";
		Start = Next.get(Next.size() - 1);
		Path += ShortestPath(Start, Updated_cost, H)
		+ "]";
	}
	}
	return Path;
}

public static void main(String[] args)
{
	Map<String, Integer> H = new HashMap<>();
	H.put("A", -1);
	H.put("B", 5);
	H.put("C", 2);
	H.put("D", 4);
	H.put("E", 7);
	H.put("F", 9);
	H.put("G", 3);
	H.put("H", 0);
	H.put("I", 0);
	H.put("J", 0);

	Map<String, Map<String, List<String> > > Conditions
	= new HashMap<>();
	Map<String, List<String> > aConditions
	= new HashMap<>();
	aConditions.put("OR", Arrays.asList("B"));
	aConditions.put("AND", Arrays.asList("C", "D"));
	Conditions.put("A", aConditions);
	Map<String, List<String> > bConditions
	= new HashMap<>();
	bConditions.put("OR", Arrays.asList("E", "F"));
	Conditions.put("B", bConditions);

	Map<String, List<String> > cConditions
	= new HashMap<>();
	cConditions.put("OR", Arrays.asList("G"));
	cConditions.put("AND", Arrays.asList("H", "I"));
	Conditions.put("C", cConditions);

	Map<String, List<String> > dConditions
	= new HashMap<>();
	dConditions.put("OR", Arrays.asList("J"));
	Conditions.put("D", dConditions);

	// weight
	int weight = 1;

	// Updated cost
	System.out.println("Updated Cost :");
	Map<String, Map<String, Integer> > Updated_cost
	= UpdateCost(H, Conditions, weight);
	System.out.println("*".repeat(75));
	System.out.println("Shortest Path :");
	System.out.println(
	ShortestPath("A", Updated_cost, H));
}
}








// hill climbing algorithm manhattan center 

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class Point {
    int x, y, n;

    Point(int x, int y, int n) {
        this.x = x;
        this.y = y;
        this.n = n;
    }

    int manhattan(Point other) {
        return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);
    }

    List<Point> generateCentre() {
        List<Point> centres = new ArrayList<>();
        int[][] directions = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
        for (int[] d : directions) {
            int newX = this.x + d[0];
            int newY = this.y + d[1];
            if (newX >= 0 && newX <= n && newY >= 0 && newY <= n) {
                centres.add(new Point(newX, newY, n));
            }
        }
        return centres;
    }

    @Override
    public String toString() {
        return "(x, y) = (" + x + ", " + y + ")";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Point point = (Point) obj;
        return x == point.x && y == point.y;
    }

    @Override
    public int hashCode() {
        return 31 * x + y;
    }
}

public class ManhattanCentre {
    static Set<Point> visited = new HashSet<>();

    public static void main(String[] args) {
        int n = 9;  // Grid dimension

        // Hardcoded coordinates of points
        int[][] coordinates = {
            {1, 1},
            {9, 4},
            {4, 6},
            {2, 5},
            {7, 7}
        };

        List<Point> pointsList = new ArrayList<>();
        for (int[] coordinate : coordinates) {
            pointsList.add(new Point(coordinate[0], coordinate[1], n));
        }

        Point initialCentre = new Point(0, 0, n);
        findCentre(pointsList, n, initialCentre);
    }

    static void findCentre(List<Point> pointsList, int n, Point centre) {
        visited.add(centre);
        System.out.println("\n--------------------------------------------------------------");
        System.out.println("Current centre: " + centre);
        System.out.println("Sum of manhattan distances (centre) :" + sum(pointsList, centre));

        List<Point> newCentres = centre.generateCentre();
        newCentres.removeAll(visited);  // Remove already visited centres

        System.out.println("\nNew centres: ");
        for (Point pt : newCentres) {
            System.out.println(pt);
        }

        List<Integer> distances = new ArrayList<>();
        for (Point pt : newCentres) {
            distances.add(sum(pointsList, pt));
        }

        System.out.println("Sum of manhattan distances from new centres: " + distances);

        int currentSum = sum(pointsList, centre);
        if (!distances.isEmpty()) {
            int minDistance = distances.stream().min(Integer::compareTo).orElse(currentSum);
            if (minDistance < currentSum) {
                Point newCentre = newCentres.get(distances.indexOf(minDistance));
                findCentre(pointsList, n, newCentre);
            } else {
                System.out.println("Finalized Minimal centre: " + centre);
                System.out.println("Cost: " + currentSum);
            }
        } else {
            System.out.println("Finalized Minimal centre: " + centre);
            System.out.println("Cost: " + currentSum);
        }
    }

    static int sum(List<Point> pointsList, Point centre) {
        return pointsList.stream().mapToInt(pt -> centre.manhattan(pt)).sum();
    }
}











//MissionariesAndCannibals (bredth first search) BFS

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;


public class MissionariesAndCannibals {
	
	HashMap<ArrayList<Integer>, HashSet<ArrayList<Integer>>> map = new HashMap<ArrayList<Integer>, HashSet<ArrayList<Integer>>>();
	Queue<ArrayList<Integer>> searchSpace = new LinkedList<ArrayList<Integer>>();
	public int MISSIONARIES;
	public int CANNIBALS;
	
	
	/**
	 * Takes in an input of missionaries and cannibals, and tells the user all the possible states, and all the states connected to those possible states
	 * The output is formatted as so
	 * [state]: (possible connecting state 1) (possible connecting state 2) ect...
	 * The program also says if there's a possible end state where all the people reach the other end of the river
	 * @param missioanries the number of starting missionaries
	 * @param cannibals the number of starting cannibals
	 */
	public MissionariesAndCannibals(int missioanries, int cannibals) {
		MISSIONARIES = missioanries;
		CANNIBALS = cannibals;
		
		ArrayList<Integer> initalState = new ArrayList<Integer>();
		initalState.add(MISSIONARIES);
		initalState.add(CANNIBALS);
		initalState.add(1);
		searchSpace.add(initalState);
		map.put(initalState, new HashSet<ArrayList<Integer>>());
		int nextSide = -1;
		while(!searchSpace.isEmpty()) {
			ArrayList<Integer> currentState = searchSpace.poll();
			if(currentState.get(2) == 0)
				nextSide = 1;
			else
				nextSide = 0;
			for (int i = 0; i <= MISSIONARIES; i++) {
				for (int j = 0; j <= CANNIBALS; j++) {
					if(possibleState(currentState,i,j) && validState(i,j) && !(i == currentState.get(0) && j == currentState.get(1))){
						ArrayList<Integer> newSpace = new ArrayList<Integer>();
						newSpace.add(i);
						newSpace.add(j);
						newSpace.add(nextSide);
						// System.out.print("Adding: ");
						// for (int num : newSpace){
						// 	System.out.print(num + " ");
						// }
						// System.out.print(" for previous state:");
						// for (int num : currentState){
						// 	System.out.print(num + " ");
						// }
						// System.out.println();
						
						if(map.get(newSpace) == null) {
//							System.out.println("state does not exist, adding");
							HashSet<ArrayList<Integer>> toAdd = new  HashSet<ArrayList<Integer>>();
							toAdd.add(currentState);
							map.put(newSpace, toAdd);
							searchSpace.add(newSpace);
						} else {
//							System.out.println("Found existing");
							map.get(newSpace).add(currentState);
						}
					}
				}
				
			}
			
		}
		for (ArrayList<Integer> key : map.keySet()) {
			System.out.print("[ ");
			for (int num : key){
				System.out.print(num + " ");
			}
			System.out.print("]: ");
			for (ArrayList<Integer> value : map.get(key)){
				System.out.print("(");
				for (int value_num : value){
					System.out.print(value_num + " ");
				}
				System.out.print(") ");
			}
			System.out.println();
		}
	
		ArrayList<Integer> testGoal = new ArrayList<Integer>();
		testGoal.add(0);
		testGoal.add(0);
		testGoal.add(0);
		if (map.get(testGoal) != null) {
			System.out.println("Has possible goal state");
		} else
			System.out.println("No possible goal state");
	}

	/**
	 * Returns if this state is possible to get to from the current state(that is, only less than 2 difference from the current state)
	 */
	private boolean possibleState(ArrayList<Integer> currentState, int i, int j) {
		if (Math.abs(currentState.get(0) - i) + Math.abs(currentState.get(1) - j) <= 2)
			if (currentState.get(2) == 1) {
				return (i <= currentState.get(0) && j <= currentState.get(1));
			} else { //the side is 0
				return (i >= currentState.get(0) && j >= currentState.get(1));
			}
		return false;
	}
	/**
	 * Returns true if this state is a valid state(that is, missionaries will not get eaten)
	 */
	private boolean validState(int i, int j) {
		if ((i >= j || i == 0) && ((MISSIONARIES - i >= CANNIBALS - j) || (MISSIONARIES - i == 0))) //check if left side is valid AND right side is valid
			return true;
			else
			return false;
	}
	public static void main(String[] args) {
		new MissionariesAndCannibals(3,2);
	}

}










// CSP graph coloring problem 

import java.io.*;
import java.util.*;
import java.util.LinkedList;

// This class represents an undirected graph using adjListacency list
public class Graph
{
	private int numOfVertices; // No. of vertices
	private LinkedList<Integer> adjList[]; //Adjacency List

	//Constructor
	Graph(int v)
	{
		numOfVertices = v;
		adjList = new LinkedList[v];
		for (int i=0; i<v; ++i)
			adjList[i] = new LinkedList();
	}

	//Function to add an edge into the graph
	void insertEdge(int v,int w)
	{
		adjList[v].add(w);
		adjList[w].add(v); //Graph is undirected
	}

	// Assigns colors (starting from 0) to all vertices and
	// prints the assignment of colors
	void graphColouring()
	{
		int arr[] = new int[numOfVertices];

		// Initialize all vertices as unassigned
		Arrays.fill(arr, -1);

		// Assign the first color to first vertex
		arr[0] = 0;

		// A temporary array to store the available colors. False
		// value of available[cr] would mean that the color cr is
		// assigned to one of its adjListacent vertices
		boolean available[] = new boolean[numOfVertices];
		
		// Initially, all colors are available
		Arrays.fill(available, true);

		// Assign colors to remaining numOfVertices-1 vertices
		for (int u = 1; u < numOfVertices; u++)
		{
			// Process all adjListacent vertices and flag their colors
			// as unavailable
			Iterator<Integer> it = adjList[u].iterator() ;
			while (it.hasNext())
			{
				int i = it.next();
				if (arr[i] != -1)
					available[arr[i]] = false;
			}

			// Find the first available color
			int cr;
			for (cr = 0; cr < numOfVertices; cr++){
				if (available[cr])
					break;
			}

			arr[u] = cr; // Assign the found color

			// Reset the values back to true for the next iteration
			Arrays.fill(available, true);
		}

		// print the arr
		for (int u = 0; u < numOfVertices; u++)
			System.out.println("numOfVerticesertex " + u + " ---> Color "
								+ arr[u]);
	}

	// Driver method
	public static void main(String args[])
	{
		Graph g1 = new Graph(5);
		g1.insertEdge(0, 1);
		g1.insertEdge(1, 2);
		g1.insertEdge(0, 2);
		g1.insertEdge(1, 3);
		g1.insertEdge(0, 4);
		System.out.println("Coloring of graph 1");
		g1.graphColouring();

	}
}








// EightPuzzle BFS

import java.util.*;

class PuzzleState {
    int[][] board;
    int x, y; // Coordinates of the blank space (0)
    PuzzleState parent; // To track the path to the solution

    public PuzzleState(int[][] board, int x, int y, PuzzleState parent) {
        this.board = new int[board.length][board.length];
        for (int i = 0; i < board.length; i++) {
            this.board[i] = board[i].clone();
        }
        this.x = x;
        this.y = y;
        this.parent = parent;
    }

    // Check if this state is the goal state
    public boolean isGoal() {
        int[][] goal = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 0}
        };
        return Arrays.deepEquals(this.board, goal);
    }

    // Generate successors of the current state
    public List<PuzzleState> generateSuccessors() {
        List<PuzzleState> successors = new ArrayList<>();
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        for (int i = 0; i < 4; i++) {
            int newX = x + dx[i];
            int newY = y + dy[i];

            if (isInBounds(newX, newY)) {
                int[][] newBoard = copyBoard(this.board);
                swap(newBoard, x, y, newX, newY);
                successors.add(new PuzzleState(newBoard, newX, newY, this));
            }
        }

        return successors;
    }

    // Check if coordinates are within bounds of the board
    private boolean isInBounds(int x, int y) {
        return x >= 0 && x < board.length && y >= 0 && y < board.length;
    }

    // Swap the values in the board
    private void swap(int[][] board, int x1, int y1, int x2, int y2) {
        int temp = board[x1][y1];
        board[x1][y1] = board[x2][y2];
        board[x2][y2] = temp;
    }

    // Create a copy of the board
    private int[][] copyBoard(int[][] board) {
        int[][] newBoard = new int[board.length][];
        for (int i = 0; i < board.length; i++) {
            newBoard[i] = board[i].clone();
        }
        return newBoard;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PuzzleState that = (PuzzleState) o;
        return Arrays.deepEquals(board, that.board);
    }

    @Override
    public int hashCode() {
        return Arrays.deepHashCode(board);
    }
}

public class EightPuzzleBFS {
    public static void main(String[] args) {
        int[][] initialBoard = {
            {1, 0, 3},
            {4, 2, 5},
            {7, 8, 6}
        };

        PuzzleState initialState = new PuzzleState(initialBoard, 1, 1, null);
        if (bfs(initialState)) {
            System.out.println("Solution found.");
        } else {
            System.out.println("No solution exists.");
        }
    }

    public static boolean bfs(PuzzleState initialState) {
        Queue<PuzzleState> frontier = new LinkedList<>();
        Set<PuzzleState> explored = new HashSet<>();
        int nodesVisited = 0;
        int branches = 0;

        frontier.add(initialState);

        while (!frontier.isEmpty()) {
            PuzzleState current = frontier.poll();
            explored.add(current);
            nodesVisited++;

            if (current.isGoal()) {
                System.out.println("Total nodes visited: " + nodesVisited);
                System.out.println("Total cost (depth of solution): " + getDepth(current));
                System.out.println("Number of branches: " + branches);
                printSolutionPath(current);
                return true;
            }

            List<PuzzleState> successors = current.generateSuccessors();
            branches += successors.size();
            for (PuzzleState successor : successors) {
                if (!explored.contains(successor) && !frontier.contains(successor)) {
                    frontier.add(successor);
                }
            }

            System.out.println("Frontier size: " + frontier.size());
        }

        return false;
    }

    // Get the depth of the solution by counting the number of parents
    private static int getDepth(PuzzleState state) {
        int depth = 0;
        while (state.parent != null) {
            depth++;
            state = state.parent;
        }
        return depth;
    }

    // Print the path from the initial state to the goal state
    private static void printSolutionPath(PuzzleState state) {
        List<PuzzleState> path = new ArrayList<>();
        while (state != null) {
            path.add(state);
            state = state.parent;
        }
        Collections.reverse(path);
        for (PuzzleState step : path) {
            printBoard(step.board);
            System.out.println();
        }
    }

    // Print the board
    private static void printBoard(int[][] board) {
        for (int[] row : board) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }
}







//insect identification prolog

insect(ant, small, brown, six_legs, no_wings, social, ground).
insect(ant, small, black, six_legs, no_wings, social, ground).
insect(bee, small, yellow, six_legs, two_wings, social, flowers).
insect(butterfly, small, colorful, six_legs, two_wings, solitary, gardens).
insect(spider, tiny, brown, eight_legs, no_wings, solitary, house).
insect(ladybug, small, red, six_legs, two_wings, solitary, plants).
insect(mosquito, small, gray, six_legs, two_wings, solitary, wetlands).
insect(grasshopper, medium, green, six_legs, two_wings, solitary, grassy_fields).
insect(beetle, small, black, six_legs, two_wings, solitary, forests).
insect(praying_mantis, medium, green, six_legs, two_wings, solitary, gardens).
insect(dragonfly, medium, iridescent, six_legs, two_wings, solitary, ponds).
insect(centipede, medium, brown, many_legs, no_wings, solitary, dark_damp_places).
insect(fly, small, black, six_legs, two_wings, solitary, various).
insect(wasp, small, black_and_yellow, six_legs, two_wings, solitary, nests).
insect(ant, small, red, six_legs, no_wings, social, ground).
insect(bumblebee, medium, black_and_yellow, six_legs, two_wings, social, flowers).
insect(damselfly, small, blue, six_legs, two_wings, solitary, ponds).
insect(firefly, small, bioluminescent, six_legs, two_wings, solitary, fields).
insect(earwig, small, dark_brown, six_legs, two_wings, solitary, dark_damp_places).

identify_insect(Color, Size, Legs, Wings, Social, Habitat, Insect) :-
    insect(Insect, Size, Color, Legs, Wings, Social, Habitat).

start :-
    write('Welcome to the Insect Identifier!'), nl,
    write('Please describe the insect you want to identify.'), nl,
    write('What is the color of the insect? '), read(Color), nl,
    write('What is the size of the insect (small, medium, large)? '), read(Size), nl,
    write('How many legs does the insect have? (six_legs, eight_legs or many_legs?)'), read(Legs), nl,
    write('How many wings does the insect have? (two_wings or no_wings)? '), read(Wings), nl,
    write('Is the insect social (social or solitary)? '), read(Social), nl,
    write('Where is the insect commonly found (e.g., "forests," "flowers", "various")? '), read(Habitat), nl,
    identify_insect(Color, Size, Legs, Wings, Social, Habitat, Insect),
    (
        Insect \= [] -> write('Based on your description, the insect may be a '), write(Insect), nl
        ; write('No insect identified based on your given information'), nl
    ).


//family tree 

% Male and Female relationships
male(varad).
father(prashant, varad).
mother(sarika, varad).
female(sunanda).
female(manjusha).
female(kavita).
female(madhu).
female(shruti).
female(gauri).
female(riya).
female(shreya).
female(jui).
female(munni).
female(shraddha).
female(swapna).
female(nirmala).
female(sia).

% Grandparent relationships
grandfather(purushuttam, varad).
grandfather(chandrakant, varad).
grandmother(sunanda, varad).
grandmother(nirmala, varad).

% Aunt and Uncle relationships
aunt(manjusha, varad).
aunt(kavita, varad).
aunt(madhu, varad).
aunt(munni, varad).
aunt(shraddha, varad).
aunt(swapna, varad).
uncle(shekhar, varad).
uncle(mayur, varad).
uncle(ankush, varad).
uncle(jai, varad).
uncle(nikhil, varad).
uncle(karan, varad).

% Cousin relationships
cousin(shruti, varad).
cousin(gauri, varad).
cousin(riya, varad).
cousin(shreya, varad).
cousin(jui, varad).
cousin(aniket, varad).
cousin(nimish, varad).
cousin(arnav, varad).

% Third aunt's family
husband(nikhil, shreya).
husband(karan, jui).
child(sia, shreya).

% Parent relationships
parent(prashant, varad).
parent(sarika, varad).

% Niece relationships
niece(sia, varad).

% Sibling relationships
sibling(shruti, gauri).
sibling(jui, shreya).

% Marital relationships
married(prashant, sarika).
married(nikhil, shreya).
married(karan, jui).
married(shekhar, manjusha).
married(shekhar, madhu).
married(ankush, shraddha).
married(jai, swapna).
married(munni, mayur).

% Additional rules for family relationships
mother_of(X, Y) :- mother(X, Y).
father_of(X, Y) :- father(X, Y).
sister_of(X, Y) :- female(X), sibling(X, Y).
grandparent_of(X, Y) :- (grandfather(X, Y); grandmother(X, Y)).
aunt_of(X, Y) :- female(X), (sister_of(X, Z), parent_of(Z, Y); married(X, Z), sibling(Z, W), parent_of(W, Y)).
uncle_of(X, Y) :- male(X), (brother_of(X, Z), parent_of(Z, Y); married(X, Z), sibling(Z, W), parent_of(W, Y)).
cousin_of(X, Y) :-(aunt_of(Z, Y); uncle_of(Z, Y)), parent(Z, X), X \= Y.


//familyTree 2 

% Male and Female relationships
male(varad).
male(prashant).
male(shekhar).
female(sarika).
female(manjusha).
female(kavita).

% Parent relationships
parent(prashant, varad).
parent(sarika, varad).
parent(prashant, kavita).
parent(sarika, kavita).
parent(shekhar, manjusha).
parent(shekhar, prashant).

% Sibling relationships
sibling(X, Y) :- parent(Z, X), parent(Z, Y), X \= Y.

% Grandparent relationships
grandparent(X, Y) :- parent(X, Z), parent(Z, Y).

% Aunt and Uncle relationships
aunt(X, Y) :- female(X), sibling(X, Z), parent(Z, Y).
uncle(X, Y) :- male(X), sibling(X, Z), parent(Z, Y).

% Cousin relationships
cousin(X, Y) :- parent(Z, X), sibling(Z, W), parent(W, Y).

% Additional rules for family relationships
mother_of(X, Y) :- female(X), parent(X, Y).
father_of(X, Y) :- male(X), parent(X, Y).
sister_of(X, Y) :- female(X), sibling(X, Y).
brother_of(X, Y) :- male(X), sibling(X, Y).
grandparent_of(X, Y) :- grandparent(X, Y).
aunt_of(X, Y) :- aunt(X, Y).
uncle_of(X, Y) :- uncle(X, Y).
cousin_of(X, Y) :- cousin(X, Y).

% Define mother and father predicates
mother(sarika, varad).
father(prashant, varad).


//?- parent(Who, varad).
//?- sibling(varad, Who).
//?- grandparent(Who, varad).
